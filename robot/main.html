<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robot Canvas</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="robotContainer">
        <h1>Robot Canvas</h1>
        <p>
            Welcome to the Robot Canvas! Use the buttons below to turn the robot on/off and charge it. 
            Click on anywhere on the canvas to fire lasers at that point, click on the left or right side of the canvas to move the robot, 
            or click on the area near its arm to make it spin. The robot can perform up to 3 actions before it needs to be charged.
        </p>
        <canvas id="robotCanvas" width="500" height="500"></canvas>
        <div class="button-container">
            <button id="onOffButton">Turn On/Off</button>
            <button id="chargeButton">Charge Robot</button>
        </div>
        <p>
            This program works on both desktop and mobile devices. To interact, tap or click on the canvas and use the buttons. 
            For mobile users, ensure your screen is in portrait mode for the best experience.
        </p>

    </div>
    
    <script>
        const canvas = document.getElementById("robotCanvas");
        const ctx = canvas.getContext("2d");
        let isRobotOn = false;
        let batteryLevel = 3;
        const robot = { x: 250, y: 250, armAngle: 0, width: 100, height: 120, armSpinDuration: 0 }; 
        let armSpinTimer = null;
        let isCharging = false;
        let isLeftLegRaised = false;
        let isRightLegRaised = false;

        function drawRobot() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // canvas border glow
            ctx.shadowColor = "#0ea5e9";
            ctx.shadowBlur = 25;

            // robot body (with gradient)
            let bodyGradient = ctx.createLinearGradient(robot.x - 50, robot.y - 120, robot.x + 50, robot.y);
            bodyGradient.addColorStop(0, isRobotOn ? "#94a3b8" : "#6b7280");
            bodyGradient.addColorStop(1, "#1e293b");
            ctx.fillStyle = bodyGradient;
            ctx.fillRect(robot.x - robot.width / 2, robot.y - robot.height, robot.width, robot.height);

            // robot head (metallic + shadow)
            let headGradient = ctx.createRadialGradient(robot.x, robot.y - robot.height - 40, 10, robot.x, robot.y - robot.height - 40, 40);
            headGradient.addColorStop(0, "#f1f5f9");
            headGradient.addColorStop(1, "#64748b");
            ctx.beginPath();
            ctx.fillStyle = headGradient;
            ctx.arc(robot.x, robot.y - robot.height - 40, 40, 0, Math.PI * 2);
            ctx.fill();

            // robot eyes (glowing red when on)
            ctx.fillStyle = isRobotOn ? "#ef4444" : "#1e293b";
            ctx.shadowBlur = isRobotOn ? 20 : 0;
            ctx.beginPath();
            ctx.arc(robot.x - 15, robot.y - robot.height - 50, 8, 0, Math.PI * 2);
            ctx.arc(robot.x + 15, robot.y - robot.height - 50, 8, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0; // reset shadow

            // mouth
            ctx.fillStyle = "#111";
            ctx.fillRect(robot.x - 20, robot.y - robot.height - 30, 40, 10);

            // arms
            ctx.fillStyle = "#f472b6"; // soft pink
            drawArm(robot.x - 60, robot.y - 60, robot.armAngle, "left");
            drawArm(robot.x + 60, robot.y - 60, -robot.armAngle, "right");

            // shoulders
            drawShoulders();

            // legs
            drawLeg(robot.x - 30, robot.y, isLeftLegRaised);
            drawLeg(robot.x + 30, robot.y, isRightLegRaised);

            // antenna
            drawAntenna(robot.x, robot.y - robot.height - 70);

            // battery + charging cable
            drawBattery();
            if (isCharging) drawChargingCable();
        }

        function drawShoulders() {
            const shoulderWidth = 20;
            const shoulderHeight = 20;
            ctx.fillStyle = "#f472b6"; 
            ctx.fillRect(robot.x - 70, robot.y - 67, shoulderWidth, shoulderHeight);
            ctx.fillRect(robot.x + 50, robot.y - 67, shoulderWidth, shoulderHeight);
        }

        function drawArm(x, y, angle, side) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle);
            let armGradient = ctx.createLinearGradient(-8, 0, 8, 60);
            armGradient.addColorStop(0, "#f472b6");
            armGradient.addColorStop(1, "#db2777");
            ctx.fillStyle = armGradient;
            ctx.fillRect(-8, -8, 16, 60);
            ctx.beginPath();
            ctx.fillStyle = "#1f2937";
            ctx.arc(0, 60, 12, Math.PI, 0);
            ctx.fill();
            ctx.restore();
        }

        function drawAntenna(x, y) {
            ctx.strokeStyle = "#e11d48";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x, y - 30);
            ctx.stroke();
            ctx.fillStyle = "#dc2626";
            ctx.shadowColor = "#f87171";
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(x, y - 30, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        function drawLeg(x, y, isRaised) {
            ctx.fillStyle = "#f472b6";
            if (isRaised) {
                ctx.fillRect(x - 12, y - 40, 24, 60);
                ctx.beginPath();
                ctx.fillStyle = "#0f172a";
                ctx.arc(x, y + 20, 15, 0, Math.PI, true);
                ctx.fill();
            } else {
                ctx.fillRect(x - 12, y, 24, 100);
                ctx.beginPath();
                ctx.fillStyle = "#0f172a";
                ctx.arc(x, y + 100, 15, 0, Math.PI, true);
                ctx.fill();
            }
        }

        function drawBattery() {
            const batteryX = 10, batteryY = 10, batteryWidth = 60, batteryHeight = 20;
            ctx.strokeStyle = "#0ea5e9";
            ctx.lineWidth = 2;
            ctx.strokeRect(batteryX, batteryY, batteryWidth, batteryHeight);
            ctx.fillStyle = "#0ea5e9";
            ctx.fillRect(batteryX + batteryWidth, batteryY + 5, 5, 10);

            for (let i = 0; i < batteryLevel; i++) {
                ctx.fillStyle = "limegreen";
                ctx.fillRect(batteryX + 5 + i * 20, batteryY + 3, 15, 14);
            }
        }

        function drawChargingCable() {
            const cableX = robot.x;
            const cableYStart = robot.y + 30;
            const cableYEnd = cableYStart + 400;
            ctx.strokeStyle = "#334155";
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(cableX, cableYStart);
            ctx.lineTo(cableX, cableYEnd);
            ctx.stroke();

            ctx.fillStyle = "#1e3a8a";
            ctx.fillRect(cableX - 15, cableYStart - 20, 30, 20);

            ctx.fillStyle = "#000";
            ctx.fillRect(cableX - 7, cableYStart - 30, 4, 10);
            ctx.fillRect(cableX + 3, cableYStart - 30, 4, 10);
        }



        // Function for fire lasers from robot's eyes
        function fireLasers(x, y) {
            if (!isRobotOn || batteryLevel === 0) return;
            const laserColor = "red";
            const laserWidth = 5;

            // laser starting points from the robot's eyes
            const leftEyeX = robot.x - 15;
            const rightEyeX = robot.x + 15;
            const eyeY = robot.y - robot.height - 50;

            // Draw lasers from both eyes to the clicked position
            ctx.strokeStyle = laserColor;
            ctx.shadowColor = laserColor;
            ctx.shadowBlur = 20;
            ctx.lineWidth = laserWidth;


            // Laser from left eye
            ctx.beginPath();
            ctx.moveTo(leftEyeX, eyeY);
            ctx.lineTo(x, y);
            ctx.stroke();

            // Laser from right eye
            ctx.beginPath();
            ctx.moveTo(rightEyeX, eyeY);
            ctx.lineTo(x, y);
            ctx.stroke();

            ctx.shadowBlur = 0;
            ctx.shadowColor = "transparent";


            // Reduce battery after firing lasers
            batteryLevel--;
            if (batteryLevel < 0) batteryLevel = 0;

            // Laser removed after 2 seconds
            setTimeout(() => {
                drawRobot();
            }, 2000);
        }

        let walkingPhase = 0;
        // Function for moving the robot to the left or right side of the canvas
        function moveRobot(side) {
            if (!isRobotOn || batteryLevel === 0) return;
            const moveDistance = 50, steps = 2, stepDuration = 200;
            let currentStep = 0;
            const moveInterval = setInterval(() => {
                if (currentStep > steps) {
                    clearInterval(moveInterval);
                    // Reseting legs to normal orientation after completing movement
                    isLeftLegRaised = false;
                    isRightLegRaised = false;
                    drawRobot();
                    return;
                }
                // Alternate leg positions during movement
                if (currentStep < steps) {
                    if (currentStep % 2 === 0) {
                        isLeftLegRaised = true;
                        isRightLegRaised = false;
                    } else {
                        isLeftLegRaised = false;
                        isRightLegRaised = true;
                    }
                } else {
                    // Finally reset both legs to normal
                    isLeftLegRaised = false;
                    isRightLegRaised = false;
                }
                // Move the robot in the specified direction
                if (side === "left") {
                    robot.x -= moveDistance / steps;
                } else if (side === "right") {
                    robot.x += moveDistance / steps;
                }

                drawRobot();
                currentStep++;
            }, stepDuration);
            batteryLevel--;
                if (batteryLevel < 0) batteryLevel = 0;
        }

        // Function to spin the arm for a few seconds
        function spinArm() {
            if (!isRobotOn || batteryLevel === 0) return;
            const spinDuration = 4000; // 4 seconds
            const spinSpeed = 0.1; // Speed of rotation
            // to spin arm for 4 seconds
            armSpinTimer = setInterval(() => {
                robot.armAngle += spinSpeed;
                drawRobot();
            }, 100);
            // Stop the arm spin after the duration
            setTimeout(() => {
                clearInterval(armSpinTimer);
                armSpinTimer = null;
            }, spinDuration);
            
            batteryLevel--;
            if (batteryLevel < 0) batteryLevel = 0;
            drawRobot();
        }

        // Update robot state
        document.getElementById("onOffButton").addEventListener("click", () => {
            if (batteryLevel > 0) {
                isRobotOn = !isRobotOn;
                drawRobot();
            }
        });


        // clicking on canvas
        canvas.addEventListener("click", (event) => {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            // Define the left and right side boundaries for users to click on when moving the robot
            const boundaryMargin = 30;

            // Check if clicked near the left or right boundary to prioritize movement
            if (x < boundaryMargin) {
                moveRobot("left");
            } else if (x > canvas.width - boundaryMargin) {
                moveRobot("right");
            } else {
                // near the robot's arm (left and right arm area)
                const armAreaMargin = 50; 

                // Left arm area (x coordinate is robot.x - 60 and the arm width is 16)
                if (x > robot.x - 60 - armAreaMargin && x < robot.x - 60 + 16 + armAreaMargin &&
                    y > robot.y - 60 && y < robot.y - 60 + 60) {
                    spinArm(); // Spin the arm if clicked near the left arm
                } 
                // Right arm area (x coordinate is robot.x + 60 and the arm width is 16)
                else if (x > robot.x + 60 - armAreaMargin && x < robot.x + 60 + 16 + armAreaMargin &&
                    y > robot.y - 60 && y < robot.y - 60 + 60) {
                    spinArm(); // Spin the arm if clicked near the right arm
                } 
                else {
                    // fire lasers
                    fireLasers(x, y);
                }
            }
        });

        document.getElementById("chargeButton").addEventListener("click", () => {
            isCharging = true; // Show the charging cable
            drawRobot();

            // Incrementally charge the battery
            let chargeInterval = setInterval(() => {
                if (batteryLevel < 3) {
                    batteryLevel++;
                    drawRobot();
                } else {
                    clearInterval(chargeInterval); // Stop charging once fully charged
                    isCharging = false; // Hide the charging cable
                    drawRobot();
                }
            }, 1000); // 1 second delay for each bar to load
        });

        // Initial drawing
        drawRobot();
    </script>
</body>
</html>
>